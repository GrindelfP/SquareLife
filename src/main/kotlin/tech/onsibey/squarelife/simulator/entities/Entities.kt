package tech.onsibey.squarelife.simulator.entities

import tech.onsibey.squarelife.common.EntitySize.KUVAHAKU_SIZE
import tech.onsibey.squarelife.common.EntitySize.KUVAT_SIZE
import tech.onsibey.squarelife.common.EntitySize.UUTISET_SIZE
import tech.onsibey.squarelife.visualisation.Color
import java.util.UUID.randomUUID
import kotlin.random.Random

/**
 * Sealed class, representing the general data and functionality of the entities.
 * It's a base class for all the specified entity classes. It contains properties:
 * - color - entity color
 * - size - entity size, also these properties are passed as parameters:
 *
 * @param position entity position
 * @param id entity id (generated by default)
 * @param alive entity is alive (true by default)
 */
sealed class Entity(
    private var position: Position,
    val id: String = randomUUID().toString(),
    var alive: Boolean = true
) {

    abstract val color: Color
    abstract val size: Int

    /**
     * Function validates entity position. Requires entity to occupy exact same world, as it needs.
     */
    fun validate(entity: Class<in Entity>, area: Int) {  // Class<in Entity> can be replaced by String that reflects entity name
        require(position.coordinates.size == area) {
            "${entity.simpleName} must occupy $area coordinates, number of supplied coordinates is " +
                    "${position.coordinates.size}"
        }
    }

    /**
     * Function-getter for this.position.
     */
    fun position(): Position = position

    /**
     * Function-setter for this.position.
     */
    fun position(newPosition: Position) {
        position = newPosition
    }

    /**
     * Function returns a set of common coordinates of this Entity instance with other instance.
     */
    fun commonCoordinates(other: Entity) = position().coordinates.intersect(other.position().coordinates)

    /**
     * Function to move this entity on board.
     */
    fun move() {
        val positions = position().possibleMoveCoordinates() // possible move coordinates
        // we can move only when we have alternatives to move to
        if (positions.isNotEmpty()) { // if we have alternatives
            val randomElementIndex = Random.nextInt(0, positions.size) // get random index
            position = positions[randomElementIndex] // move to new position picked randomly
        }
    }
}

/**
 * Data class representing a Kuvahaku entity. Inherits from Entity sealed class.
 * It contains properties:
 * - color - is set to Color.BLUE color
 * - size - is set to KUVAHAKU_SIZE, also this property is taken as a parameter:
 * @param position this entity position
 */
data class Kuvahaku(private var position: Position) : Entity(position) {

    override val color: Color = Color.BLUE
    override val size: Int = KUVAHAKU_SIZE

    /**
     * Constructor validates entity position.
     */
    init {
        validate(entity = javaClass, area = size * size)
    }
}

/**
 * Data class representing a Kuvat entity. Inherits from Entity sealed class.
 * It contains properties:
 * - color - is set to Color.GREEN color
 * - size - is set to KUVAT_SIZE, also this property is taken as a parameter:
 * @param position this entity position
 */
data class Kuvat(private var position: Position) : Entity(position) {
    override val color: Color = Color.GREEN
    override val size: Int = KUVAT_SIZE

    /**
     * Constructor validates entity position.
     */
    init {
        validate(javaClass, size * size)
    }
}

/**
 * Data class representing an Uutiset entity. Inherits from Entity sealed class.
 * It contains properties:
 * - color - is set to Color.RED color
 * - size - is set to UUTISET_SIZE, also this property is taken as a parameter:
 * @param position this entity position
 */
data class Uutiset(private var position: Position) : Entity(position) {

    override val color: Color = Color.RED
    override val size: Int = UUTISET_SIZE

    /**
     * Constructor validates entity position.
     */
    init {
        validate(javaClass, size * size)
    }
}

/**
 * Mates class, representing two entities that are mated together.
 */
data class Mates(val first: Entity, val second: Entity) {
    /**
     * Function returns a string representation of this Mates instance.
     */
    override fun toString(): String {
        return "Mates: \nfirst: ${first::class.simpleName} - ${first.id} - ${first.position()}, " +
                "\nsecond: ${second::class.simpleName} - ${second.id} - ${second.position()}"
    }
}
